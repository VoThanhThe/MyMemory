"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Web3Modal = void 0;
var _core = require("@wagmi/core");
var _chains = require("@wagmi/core/chains");
var _scaffoldReactNative = require("@web3modal/scaffold-react-native");
var _scaffoldUtilsReactNative = require("@web3modal/scaffold-utils-react-native");
var _helpers = require("./utils/helpers");
// -- Types ---------------------------------------------------------------------

// @ts-expect-error: Overriden state type is correct

// -- Client --------------------------------------------------------------------
class Web3Modal extends _scaffoldReactNative.Web3ModalScaffold {
  hasSyncedConnectedAccount = false;
  options = undefined;
  constructor(options) {
    const {
      wagmiConfig,
      chains,
      defaultChain,
      tokens,
      _sdkVersion,
      ...w3mOptions
    } = options;
    if (!wagmiConfig) {
      throw new Error('web3modal:constructor - wagmiConfig is undefined');
    }
    if (!w3mOptions.projectId) {
      throw new Error('web3modal:constructor - projectId is undefined');
    }
    const networkControllerClient = {
      switchCaipNetwork: async caipNetwork => {
        const chainId = _scaffoldUtilsReactNative.HelpersUtil.caipNetworkIdToNumber(caipNetwork?.id);
        if (chainId) {
          await (0, _core.switchNetwork)({
            chainId
          });
        }
      },
      async getApprovedCaipNetworksData() {
        const walletChoice = await _scaffoldUtilsReactNative.StorageUtil.getConnectedConnector();
        const walletConnectType = _scaffoldUtilsReactNative.PresetsUtil.ConnectorTypesMap[_scaffoldUtilsReactNative.ConstantsUtil.WALLET_CONNECT_CONNECTOR_ID];
        if (walletChoice?.includes(walletConnectType)) {
          const connector = wagmiConfig.connectors.find(c => c.id === _scaffoldUtilsReactNative.ConstantsUtil.WALLET_CONNECT_CONNECTOR_ID);
          if (!connector) {
            throw new Error('networkControllerClient:getApprovedCaipNetworks - connector is undefined');
          }
          const provider = await connector.getProvider();
          const ns = provider.signer?.session?.namespaces;
          const nsMethods = ns?.[_scaffoldUtilsReactNative.ConstantsUtil.EIP155]?.methods;
          const nsChains = ns?.[_scaffoldUtilsReactNative.ConstantsUtil.EIP155]?.chains;
          return {
            supportsAllNetworks: nsMethods?.includes(_scaffoldUtilsReactNative.ConstantsUtil.ADD_CHAIN_METHOD),
            approvedCaipNetworkIds: nsChains
          };
        }
        return {
          approvedCaipNetworkIds: undefined,
          supportsAllNetworks: true
        };
      }
    };
    const connectionControllerClient = {
      connectWalletConnect: async onUri => {
        const connector = wagmiConfig.connectors.find(c => c.id === _scaffoldUtilsReactNative.ConstantsUtil.WALLET_CONNECT_CONNECTOR_ID);
        if (!connector) {
          throw new Error('connectionControllerClient:getWalletConnectUri - connector is undefined');
        }
        connector.on('message', event => {
          if (event.type === 'display_uri') {
            onUri(event.data);
            connector.removeAllListeners();
          }
        });
        const chainId = _scaffoldUtilsReactNative.HelpersUtil.caipNetworkIdToNumber(this.getCaipNetwork()?.id);
        await (0, _core.connect)({
          connector,
          chainId
        });
      },
      connectExternal: async ({
        id
      }) => {
        const connector = wagmiConfig.connectors.find(c => c.id === id);
        if (!connector) {
          throw new Error('connectionControllerClient:connectExternal - connector is undefined');
        }
        const chainId = _scaffoldUtilsReactNative.HelpersUtil.caipNetworkIdToNumber(this.getCaipNetwork()?.id);
        await (0, _core.connect)({
          connector,
          chainId
        });
      },
      disconnect: _core.disconnect
    };
    super({
      networkControllerClient,
      connectionControllerClient,
      defaultChain: (0, _helpers.getCaipDefaultChain)(defaultChain),
      tokens: _scaffoldUtilsReactNative.HelpersUtil.getCaipTokens(tokens),
      _sdkVersion: _sdkVersion ?? `react-native-wagmi-${_scaffoldUtilsReactNative.ConstantsUtil.VERSION}`,
      ...w3mOptions
    });
    this.options = options;
    this.syncRequestedNetworks(chains);
    this.syncConnectors(wagmiConfig);
    (0, _core.watchAccount)(() => this.syncAccount());
    (0, _core.watchNetwork)(() => this.syncNetwork());
  }

  // -- Public ------------------------------------------------------------------

  // @ts-expect-error: Overriden state type is correct
  getState() {
    const state = super.getState();
    return {
      ...state,
      selectedNetworkId: _scaffoldUtilsReactNative.HelpersUtil.caipNetworkIdToNumber(state.selectedNetworkId)
    };
  }

  // @ts-expect-error: Overriden state type is correct
  subscribeState(callback) {
    return super.subscribeState(state => callback({
      ...state,
      selectedNetworkId: _scaffoldUtilsReactNative.HelpersUtil.caipNetworkIdToNumber(state.selectedNetworkId)
    }));
  }

  // -- Private -----------------------------------------------------------------
  syncRequestedNetworks(chains) {
    const requestedCaipNetworks = chains?.map(chain => ({
      id: `${_scaffoldUtilsReactNative.ConstantsUtil.EIP155}:${chain.id}`,
      name: chain.name,
      imageId: _scaffoldUtilsReactNative.PresetsUtil.EIP155NetworkImageIds[chain.id],
      imageUrl: this.options?.chainImages?.[chain.id]
    }));
    this.setRequestedCaipNetworks(requestedCaipNetworks ?? []);
  }
  async syncAccount() {
    const {
      address,
      isConnected
    } = (0, _core.getAccount)();
    const {
      chain
    } = (0, _core.getNetwork)();
    this.resetAccount();
    if (isConnected && address && chain) {
      const caipAddress = `${_scaffoldUtilsReactNative.ConstantsUtil.EIP155}:${chain.id}:${address}`;
      this.setIsConnected(isConnected);
      this.setCaipAddress(caipAddress);
      await Promise.all([this.syncProfile(address), this.syncBalance(address, chain), this.getApprovedCaipNetworksData()]);
      this.hasSyncedConnectedAccount = true;
    } else if (!isConnected && this.hasSyncedConnectedAccount) {
      this.resetWcConnection();
      this.resetNetwork();
    }
  }
  async syncNetwork() {
    const {
      address,
      isConnected
    } = (0, _core.getAccount)();
    const {
      chain
    } = (0, _core.getNetwork)();
    if (chain) {
      const chainId = String(chain.id);
      const caipChainId = `${_scaffoldUtilsReactNative.ConstantsUtil.EIP155}:${chainId}`;
      this.setCaipNetwork({
        id: caipChainId,
        name: chain.name,
        imageId: _scaffoldUtilsReactNative.PresetsUtil.EIP155NetworkImageIds[chain.id],
        imageUrl: this.options?.chainImages?.[chain.id]
      });
      if (isConnected && address) {
        const caipAddress = `${_scaffoldUtilsReactNative.ConstantsUtil.EIP155}:${chain.id}:${address}`;
        this.setCaipAddress(caipAddress);
        if (chain.blockExplorers?.default?.url) {
          const url = `${chain.blockExplorers.default.url}/address/${address}`;
          this.setAddressExplorerUrl(url);
        } else {
          this.setAddressExplorerUrl(undefined);
        }
        if (this.hasSyncedConnectedAccount) {
          await this.syncBalance(address, chain);
        }
      }
    }
  }
  async syncProfile(address) {
    try {
      const response = await this.fetchIdentity({
        caipChainId: `${_scaffoldUtilsReactNative.ConstantsUtil.EIP155}:${_chains.mainnet.id}`,
        address
      });
      if (!response) {
        throw new Error('Couldnt fetch idendity');
      }
      const {
        name,
        avatar
      } = response;
      this.setProfileName(name);
      this.setProfileImage(avatar);
    } catch {
      const profileName = await (0, _core.fetchEnsName)({
        address,
        chainId: _chains.mainnet.id
      });
      if (profileName) {
        this.setProfileName(profileName);
        const profileImage = await (0, _core.fetchEnsAvatar)({
          name: profileName,
          chainId: _chains.mainnet.id
        });
        if (profileImage) {
          this.setProfileImage(profileImage);
        }
      }
    }
  }
  async syncBalance(address, chain) {
    const balance = await (0, _core.fetchBalance)({
      address,
      chainId: chain.id,
      token: this.options?.tokens?.[chain.id]?.address
    });
    this.setBalance(balance.formatted, balance.symbol);
  }
  syncConnectors(wagmiConfig) {
    const w3mConnectors = [];
    wagmiConfig.connectors.forEach(({
      id,
      name
    }) => {
      w3mConnectors.push({
        id,
        explorerId: _scaffoldUtilsReactNative.PresetsUtil.ConnectorExplorerIds[id],
        imageId: _scaffoldUtilsReactNative.PresetsUtil.ConnectorImageIds[id],
        imageUrl: this.options?.connectorImages?.[id],
        name: _scaffoldUtilsReactNative.PresetsUtil.ConnectorNamesMap[id] ?? name,
        type: _scaffoldUtilsReactNative.PresetsUtil.ConnectorTypesMap[id] ?? 'EXTERNAL'
      });
    });
    this.setConnectors(w3mConnectors);
  }
}
exports.Web3Modal = Web3Modal;
//# sourceMappingURL=client.js.map