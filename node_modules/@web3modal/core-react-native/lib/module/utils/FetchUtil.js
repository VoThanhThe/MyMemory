// -- Types ----------------------------------------------------------------------

// -- Utility --------------------------------------------------------------------
export class FetchUtil {
  constructor({
    baseUrl
  }) {
    this.baseUrl = baseUrl;
  }
  async get({
    headers,
    ...args
  }) {
    const url = this.createUrl(args);
    const response = await fetch(url, {
      method: 'GET',
      headers
    });
    return this.processResponse(response);
  }
  async post({
    body,
    headers,
    ...args
  }) {
    const url = this.createUrl(args);
    const response = await fetch(url, {
      method: 'POST',
      headers,
      body: body ? JSON.stringify(body) : undefined
    });
    return this.processResponse(response);
  }
  async put({
    body,
    headers,
    ...args
  }) {
    const url = this.createUrl(args);
    const response = await fetch(url, {
      method: 'PUT',
      headers,
      body: body ? JSON.stringify(body) : undefined
    });
    return this.processResponse(response);
  }
  async delete({
    body,
    headers,
    ...args
  }) {
    const url = this.createUrl(args);
    const response = await fetch(url, {
      method: 'DELETE',
      headers,
      body: body ? JSON.stringify(body) : undefined
    });
    return this.processResponse(response);
  }
  async fetchImage(path, headers) {
    try {
      const url = this.createUrl({
        path
      }).toString();
      const response = await fetch(url, {
        headers
      });
      const blob = await response.blob();
      const reader = new FileReader();
      reader.readAsDataURL(blob);
      return new Promise(resolve => {
        reader.onloadend = () => resolve(reader.result);
      });
    } catch {
      return undefined;
    }
  }
  createUrl({
    path,
    params
  }) {
    const url = new URL(path, this.baseUrl);
    if (params) {
      Object.entries(params).forEach(([key, value]) => {
        if (value) {
          url.searchParams.append(key, value);
        }
      });
    }
    return url.toString();
  }
  async processResponse(response) {
    if (!response.ok) {
      const errorText = await response.text();
      return Promise.reject(`Code: ${response.status} - ${response.statusText} - ${errorText}`);
    }
    if (response.headers.get('content-length') === '0') {
      return;
    }
    if (response.headers.get('content-type')?.includes('application/json')) {
      return response.json();
    }
    return;
  }
}
//# sourceMappingURL=FetchUtil.js.map