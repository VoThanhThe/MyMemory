"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CoreHelperUtil = void 0;
var _reactNative = require("react-native");
var _ConstantsUtil = require("./ConstantsUtil");
/* eslint-disable no-bitwise */

// -- Helpers -----------------------------------------------------------------
async function isAppInstalledIos(deepLink) {
  try {
    return deepLink ? _reactNative.Linking.canOpenURL(deepLink) : Promise.resolve(false);
  } catch (error) {
    return Promise.resolve(false);
  }
}
async function isAppInstalledAndroid(packageName) {
  try {
    //@ts-ignore
    if (!packageName || typeof global?.Application?.isAppInstalled !== 'function') {
      return Promise.resolve(false);
    }

    //@ts-ignore
    return global?.Application?.isAppInstalled(packageName);
  } catch (error) {
    return Promise.resolve(false);
  }
}

// -- Utility --------------------------------------------------------------------
const CoreHelperUtil = exports.CoreHelperUtil = {
  isPairingExpired(expiry) {
    return expiry ? expiry - Date.now() <= _ConstantsUtil.ConstantsUtil.TEN_SEC_MS : true;
  },
  isAllowedRetry(lastRetry) {
    return Date.now() - lastRetry >= _ConstantsUtil.ConstantsUtil.ONE_SEC_MS;
  },
  getPairingExpiry() {
    return Date.now() + _ConstantsUtil.ConstantsUtil.FOUR_MINUTES_MS;
  },
  getPlainAddress(caipAddress) {
    return caipAddress.split(':')[2];
  },
  async wait(milliseconds) {
    return new Promise(resolve => {
      setTimeout(resolve, milliseconds);
    });
  },
  debounce(func, timeout = 500) {
    let timer;
    return (...args) => {
      function next() {
        func(...args);
      }
      if (timer) {
        clearTimeout(timer);
      }
      timer = setTimeout(next, timeout);
    };
  },
  isHttpUrl(url) {
    return url.startsWith('http://') || url.startsWith('https://');
  },
  formatNativeUrl(appUrl, wcUri) {
    if (CoreHelperUtil.isHttpUrl(appUrl)) {
      return this.formatUniversalUrl(appUrl, wcUri);
    }
    let safeAppUrl = appUrl;
    if (!safeAppUrl.includes('://')) {
      safeAppUrl = appUrl.replaceAll('/', '').replaceAll(':', '');
      safeAppUrl = `${safeAppUrl}://`;
    }
    if (!safeAppUrl.endsWith('/')) {
      safeAppUrl = `${safeAppUrl}/`;
    }
    const encodedWcUrl = encodeURIComponent(wcUri);
    return {
      redirect: `${safeAppUrl}wc?uri=${encodedWcUrl}`,
      href: safeAppUrl
    };
  },
  formatUniversalUrl(appUrl, wcUri) {
    if (!CoreHelperUtil.isHttpUrl(appUrl)) {
      return this.formatNativeUrl(appUrl, wcUri);
    }
    let safeAppUrl = appUrl;
    if (!safeAppUrl.endsWith('/')) {
      safeAppUrl = `${safeAppUrl}/`;
    }
    const encodedWcUrl = encodeURIComponent(wcUri);
    return {
      redirect: `${safeAppUrl}wc?uri=${encodedWcUrl}`,
      href: safeAppUrl
    };
  },
  openLink(url) {
    _reactNative.Linking.openURL(url);
  },
  formatBalance(balance, symbol, decimals = 3) {
    let formattedBalance;
    if (balance === '0') {
      formattedBalance = '0.000';
    } else if (typeof balance === 'string') {
      const number = Number(balance);
      if (number) {
        const regex = new RegExp(`^-?\\d+(?:\\.\\d{0,${decimals}})?`, 'u');
        formattedBalance = number.toString().match(regex)?.[0];
      }
    }
    return formattedBalance ? `${formattedBalance} ${symbol}` : `0.000 ${symbol || ''}`;
  },
  isRestrictedRegion() {
    try {
      const {
        timeZone
      } = new Intl.DateTimeFormat().resolvedOptions();
      const capTimeZone = timeZone.toUpperCase();
      return _ConstantsUtil.ConstantsUtil.RESTRICTED_TIMEZONES.includes(capTimeZone);
    } catch {
      return false;
    }
  },
  getApiUrl() {
    return CoreHelperUtil.isRestrictedRegion() ? 'https://api.web3modal.org' : 'https://api.web3modal.com';
  },
  getBlockchainApiUrl() {
    return CoreHelperUtil.isRestrictedRegion() ? 'https://rpc.walletconnect.org' : 'https://rpc.walletconnect.com';
  },
  getAnalyticsUrl() {
    return CoreHelperUtil.isRestrictedRegion() ? 'https://pulse.walletconnect.org' : 'https://pulse.walletconnect.com';
  },
  getUUID() {
    if (global?.crypto.getRandomValues) {
      const buffer = new Uint8Array(16);
      global?.crypto.getRandomValues(buffer);

      // Set the version (4) and variant (8, 9, A, or B) bits
      buffer[6] = (buffer[6] ?? 0 & 0x0f) | 0x40;
      buffer[8] = (buffer[8] ?? 0 & 0x3f) | 0x80;

      // Convert the buffer to a hexadecimal string
      const hexString = Array.from(buffer, byte => byte.toString(16).padStart(2, '0')).join('');
      const formatted = `${hexString.slice(0, 8)}-${hexString.slice(8, 12)}-${hexString.slice(12, 16)}-${hexString.slice(16, 20)}-${hexString.slice(20)}`;
      return formatted;
    }
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/gu, c => {
      const r = Math.random() * 16 | 0;
      const v = c === 'x' ? r : r & 0x3 | 0x8;
      return v.toString(16);
    });
  },
  getBundleId() {
    if (global?.Application?.applicationId) {
      return global?.Application?.applicationId;
    }
    return undefined;
  },
  async checkInstalled(wallet) {
    let isInstalled = false;
    const scheme = wallet.ios_schema;
    const appId = wallet.android_app_id;
    try {
      isInstalled = await _reactNative.Platform.select({
        ios: isAppInstalledIos(scheme),
        android: isAppInstalledAndroid(appId),
        default: Promise.resolve(false)
      });
    } catch {
      isInstalled = false;
    }
    return isInstalled;
  }
};
//# sourceMappingURL=CoreHelperUtil.js.map